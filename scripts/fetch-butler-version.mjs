/**
 * Fetch latest Butler Sheet Icons release tag and write to docs/.vitepress/version.js
 * This runs before docs:dev and docs:build. If the request fails, we keep the last
 * generated file (if any) and continue, so docs still build.
 */

import fs from "node:fs/promises";
import path from "node:path";

const OWNER = "ptarmiganlabs";
const REPO = "butler";
const API_URL = `https://api.github.com/repos/${OWNER}/${REPO}/releases/latest`;
const outFile = path.resolve("./docs/.vitepress/version.js");

async function ensureDirExists(filePath) {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
}

async function writeVersionFile(version) {
  const content = `// Auto-generated by scripts/fetch-butler-version.mjs â€“ do not edit\nexport const version = '${version}';\n`;
  await ensureDirExists(outFile);
  await fs.writeFile(outFile, content, "utf8");
}

function isValidTag(tag) {
  return typeof tag === "string" && tag.trim().length > 0;
}

async function main() {
  try {
    const headers = { "User-Agent": "bsi-docs-build-script" };
    // Use token if provided to avoid rate limiting
    const token =
      process.env.GITHUB_TOKEN ||
      process.env.GH_TOKEN ||
      process.env.GITHUB_AUTH_TOKEN;
    if (token) headers.Authorization = `Bearer ${token}`;

    const res = await fetch(API_URL, { headers });
    if (!res.ok) {
      throw new Error(`GitHub API failed with ${res.status} ${res.statusText}`);
    }
    const data = await res.json();
    const rawTag = data.tag_name;
    if (!isValidTag(rawTag)) {
      throw new Error("Invalid tag_name in GitHub API response");
    }

    // Normalize: keep from first 'v' onwards (e.g., 'butler-sheet-icons-v3.8.0' -> 'v3.8.0')
    const vIndex = rawTag.indexOf("v");
    const tag = vIndex >= 0 ? rawTag.slice(vIndex) : rawTag;

    await writeVersionFile(tag);
    console.log(`[bsi-docs] Latest ${REPO} version: ${tag}`);
  } catch (err) {
    console.warn(
      `[bsi-docs] Warning: Could not fetch latest release tag: ${err.message}`
    );
    // If the file already exists, keep it. Otherwise write a safe default.
    try {
      const existing = await fs.readFile(outFile, "utf8");
      if (existing) {
        console.log("[bsi-docs] Using existing generated version.js");
        return;
      }
    } catch {}
    const fallback = "v0.0.0";
    await writeVersionFile(fallback);
    console.log(`[bsi-docs] Wrote fallback version ${fallback}`);
  }
}

main();
